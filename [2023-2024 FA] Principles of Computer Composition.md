# 23-24 FALL 计算机组成原理

> **made by IamNotLCB**

## 现代计算机系统的硬件结构

+ 运算器
  + 算数逻辑部件 ***ALU***
  + 通用寄存器组 ***GPR***
+ 存储器
  + 内存
  + 外存
+ 控制器
  + 指令寄存器 ***IR***
  + 程序计数器 ***PC***
  + 指令译码器
  + 时钟脉冲 ***CP***
    + 其工作频率称为==**计算机的主频**==
  + 时序信号发生器
  + 微操作控制部件
    + ==**微操作**==：硬件电路中不可再细分的简单操作，在==一个节拍==内完成
+ 输入设备
+ 输出设备

<img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240117133029766.png" alt="image-20240117133029766" style="zoom:50%;" />

## 计算机的性能指标

**1. 主频**

+ 单位：***MHz***

**2. 运算速度**

+ 每秒执行多少条指令或完成多少浮点运算
+ 单位：***MIPS*** （百万条指令/秒）    ***MFLOPS***（百万次浮点运算/秒）

<img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240117151710470.png" alt="image-20240117151710470" style="zoom:50%;" />

**3. 基本字长**

+ 直接参与运算的数据字的二进制位数

**4. 主存容量**

+ 主存所能存储的信息的总量

**5. 主存存取周期**

+ 对主存连续两次访问所允许的最小时间间隔

**6. 所配置的外部设备及其性能指标**



## 计算机执行程序的过程

**Load 指令：**装载寄存器指令

+ 把一个数据送入指定的寄存器，这个值可以是立即数，也可以是来自存储器的某单元。

**Store指令：**存储指令 

+ 把指定寄存器中的数据存入存储器的某个单元。

**Add指令：**加法指令 

+ 把两个寄存器中的数据相加，并把结果存到指定的寄存器。

**Jump指令：**跳传指令 

+ 跳转到新的地址去执行指令。

**[Rx]：**寄存器Rx的内容。 

**MEM[y]：**存储器中地址为y的存储单元的内容。 

**→ ：**传送



## 指令系统

**1. 指令**

+ 要求计算机进行基本操作的命令。

**2. 指令系统或指令集**

+ 一台计算机所能执行的全部指令的集合。

### 指令格式

**1. 指令的基本格式**

+ 每条指令由两部分构成：==**操作码和地址码**==

<img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240117153834374.png" alt="image-20240117153834374" style="zoom:50%;" /> 

+ **操作码：**描述指令的操作功能，即要求计算机完成什么工作。
+ **地址码：**描述与操作数有关的信息，可以是操作数本身，也可以是存放操作数的地址。
  + 源地址：提供源操作数的地址
  + 目的地址：提供存放操作结果的地址

### 指令的地址码

**1. 零地址指令**

+ 零地址指令中只有操作码，没有地址码。

<img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240117154221336.png" alt="image-20240117154221336" style="zoom:50%;" /> 

+ 通常在两种情况下可能采用零地址指令
  + 指令本身不需要任何操作数
  + 指令中所需的操作数是隐含指定的

**2. 一地址指令**

+ 指令中给出一个地址

<img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240117154655652.png" alt="image-20240117154655652" style="zoom:50%;" /> 

+ 在两种情况下可能采用一地址指令

  + 指令本身只需要一个操作数

    > A ← OP (A)

  + 指令操作需要两个操作数，指令中指明一个操作数，而另外一个操作数在默认的某个地方。

    > 如 ：累加器AC中，操作结果存放到累加器AC中。
    >
    > AC ← (AC) OP (A)

**3. 二地址指令**

+ 指令中给出两个地址，分别指出参与操作的两个源操作数，而其中有一个又表示操作结果的存放地址。

<img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240117154813000.png" alt="image-20240117154813000" style="zoom:50%;" /> 

> A1 ← (A1) OP (A2)

+ 根据存放操作数的位置不同，分为3种。
  + 寄存器-寄存器型***（R-R型）***指令
  + 存储器-存储器型***（M-M型）***指令
  + 寄存器-存储器型***（R-M型）***指令

**4. 三地址指令**

+ 指令中给出三个地址，其中两个指明参与操作的源操作数，另一个表示操作结果的存放地址。

<img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240117155051190.png" alt="image-20240117155051190" style="zoom:50%;" /> 

> A3 ← (A1) OP (A2)

**5. 多地址指令**

+ 用于描述一批数据，指令中需要多个地址来指出数据存放的首地址、长度和下标等信息。 



### 指令的操作码

**1. 指令系统中的每一条指令都有唯一确定的操作码，不同指令的操作码是不相同的。**

+ 操作码的长度决定了指令系统的最大规模
+ 若操作码的位数为==**n位**==，则该指令系统最多能有==**2^n条**==指令。

**2. 固定长度操作码**

+ 所有指令操作码的长度都是==**固定**==的，且集中放在指令的一个字段内 。
+ 有利于简化硬件设计，减少指令译码时间。

**3. 可变长度操作码**

+ 指令系统中操作码的长度有多种，不同指令的操作码的长度不完全相同。
  + 使用==**频率高**==的指令使用==**短的操作码**==
  + 使用==**频率低**==的指令使用==**较长的操作码**==
+ 可以缩短操作码的平均长度，但会使硬件设计复杂化，增加指令译码的时间和难度。 

**4. 扩展操作码技术**

+ 将操作码设计为几种不同的固定长度，且相互之间按某种规则进行扩展。
+ **优点：**
  + 可以简化硬件设计
  + 当指令总长度一定时，可以使操作码的长度随地址数的增加而减少，不同地址数的指令的操作码的长度也不同，从而有效地缩短指令总长度。 
+ 扩展操作码的方法
  + 等长扩展、不等长扩展

> 某指令系统中，**指令长度**为**16位**，**基本操作码**为**4位**，具有**3个4位**的**地址字段**。
>
> + 指令格式
>
> <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240117160139364.png" alt="image-20240117160139364" style="zoom:50%;" /> 
>
> + 采用固定长度操作码，该指令系统最多只能有**16条**指令。
>
> 在指令字长不变的情况下，希望有**61条**指令。
>
> 其中：
>
> + 15条三地址指令
> + 15条二地址指令
> + 15条一地址指令
> + 16条零地址指令
>
> 采用**等长扩展**，操作码分别为**4位、8位、12位、16位**。 
>
> <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240117160449709.png" alt="image-20240117160449709" style="zoom:50%;" /> 
>
> 采用另一种扩展方法，共**76条**。
>
> 其中：
>
> + 15条三地址指令
> + 14条二地址指令
> + 31条一地址指令
> + 16条零地址指令
>
> <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240117160614419.png" alt="image-20240117160614419" style="zoom:50%;" /> 



### 指令长度

**1. 指令长度：**指一条指令所包含的二进制代码的总位数。

+ 指令长度主要取决于操作码的长度、操作数地址的长度、操作数地址的个数。

**2. 与机器字长有简单的倍数关系**

+ 单字长指令：指令长度等于机器字长的指令
+ 半字长指令：指令长度等于半个机器字长的指令
+ 双字长指令：指令长度等于机器字长的两倍的指令

**3. 指令长度一般应是字节的整数倍。 **

**4. 在一个指令系统中，如果每条指令的长度都相同，则称为==固定长度编码格式==。**

**5. 如果不同指令的长度随指令功能而不同，则称为==可变长度编码格式==。 **



**操作数的大小（size）：操作数的位数或字节数。**

+ 主要的大小有
  **字节（8位）、半字（16位）、字（32位）、双字（64位）**



### 寻址方式

**形式地址：**指令的地址码部分给出的地址。

**有效地址：**形式地址经地址变换后才能得到操作数的真正地址。

**寻址方式：**确定指令操作数有效地址的方法。 



**1. 直接寻址** 

+ 在指令的地址码字段直接给出操作数所在主存单元的地址。

+ 简单、快速的寻址方式，但寻址范围受限于地址码字段的位数。

<img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240117162550595.png" alt="image-20240117162550595" style="zoom:50%;" /> 

**2. 间接寻址** 

+ 指令的地址码字段给出的是操作数所在内存单元的地址的地址。
  + 指令中形式地址所指定的内存单元中存放的内容才是操作数的真正地址。

+ 得到操作数需要访问==**两次**==内存，指令的执行速度比较慢 。

<img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240117162647498.png" alt="image-20240117162647498" style="zoom:50%;" /> 

**3. 间接寻址** 

+ 指令的地址码字段直接给出操作数本身，而不是操作数的地址。

+ 指令执行速度最快，得到指令的同时就得到了操作数，不需要再访问内存。



**4. 寄存器直接寻址与寄存器间接寻址** 

+ **寄存器直接寻址：**指令的地址码字段给出一个寄存器编号，该寄存器中存放的内容就是操作数。

<img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240117162811489.png" alt="image-20240117162811489" style="zoom:50%;" /> 

+ **寄存器间接寻址：**寄存器中存放的内容是操作数的地址，根据此地址访问内存取得操作数。
+ <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240117162818208.png" alt="image-20240117162818208" style="zoom:50%;" /> 

**5. 隐含寻址** 

+ 指令中不给出操作数的地址。

+ 操作数约定在某个特定的寄存器或堆栈中。



**6. 相对寻址** 

+ 将**程序计数器** ***PC***的内容与指令中给出的形式地址（偏移量）的值相加，形成操作数的有效地址。
  ***形式地址（偏移量）的值可正可负。***

+ 对于短跳转和程序的再定位很有用。 

<img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240117163142532.png" alt="image-20240117163142532" style="zoom:50%;" /> 

**7. 变址寻址** 

+ 将指令中给出的形式地址的值与==**变址寄存器**==的内容相加，形成操作数的有效地址。

+ 变址寄存器可以是专用寄存器，也可以是通用寄存器中的一个。
+ 常用于字符串处理、数组运算等成批数据处理中，主要是面向用户，解决程序循环控制问题。
+ **通常地址的变化体现在变址寄存器中，指令中的形式地址相对固定。**

<img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240117163353271.png" alt="image-20240117163353271" style="zoom:50%;" /> 

**8. 基址寻址** 

+ 把指令中给出的形式地址的值与基址寄存器的内容相加，形成操作数的有效地址。

+ 基址寄存器的内容称为==**基地址**==。
+ 基址寄存器的内容通常由操作系统或管理程序设定。
+ 主要用于将用户程序的逻辑地址转换成主存的实际地址。它面向系统，解决程序重定位和扩大寻址空间等问题。 
+ **通常地址变化体现形式地址上，基地址相对不变。**

<img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240117163511276.png" alt="image-20240117163511276" style="zoom:50%;" /> 

**8. “基址+变址”寻址** 

​               ***有效地址=（RB）+（RX）+D***

+ 其中：
  + （RB）：基址寄存器RB中的内容
  + （RX）：变址寄存器RX中的内容
  + D：指令字中给出的形式地址（偏移量）



### 指令类型与功能

**1. 数据传送类指令**

+ 将数据从一个地方传送到另一个地方。

**2. 数据运算类指令**

+ 用来实现数据的算术运算、逻辑运算和移位运算。

**3. 程序控制类指令**

+ 主要用来控制程序执行的顺序和方向。

**4. 输入输出指令**

+ 输入输出指令简称 *** I/O*** 指令

+ 主要用于实现主机与外部设备之间的信息交换



### 指令系统的设计

*在确定哪些基本功能用硬件来实现时，主要考虑3个因素：**速度、成本、灵活性。***

**1. 对指令集的基本要求**

+ **完整性、规整性、正交性、高效率、兼容性 **

+ **完整性：**在一个有限可用的存储空间内，对于任何可解的问题，编制计算程序时，指令集所提供的指令足够用。

+ **规整性：**主要包括对称性和均匀性。

  + **对称性：**所有与指令集有关的存储单元的使用、操作码的设置等都是对称的。

  + **均匀性：**指对于各种不同的操作数类型、字长、操作种类和数据存储单元，指令的设置都要同等对待。

+ **正交性：**指在指令中各个不同含义的字段，如操作类型、数据类型、寻址方式字段等，在编码时应互不相关、相互独立。
+ **高效率：**指指令的执行速度快、使用频度高。
+ **兼容性：**主要是要实现向后兼容，指令系统可以增加新指令，但不能删除指令或更改指令的功能。



**2. 在设计指令系统时，有两种截然不同的设计策略。**

+ **CISC（复杂指令系统计算机）**
  + 增强指令功能，把越来越多的功能交由硬件来实现，并且指令的数量也是越来越多。

+ **RISC（精简指令系统计算机）**
  + 尽可能地把指令系统简化，不仅指令的条数少，而且指令的功能也比较简单。 



**3. 指令格式的设计**

+ 指令由两部分组成：**操作码**、**地址码**

+ 指令格式的设计

  + 确定操作码字段和地址码字段的大小及其组合形式

  + 确定各种寻址方式的编码方法 

+ 有 **3** 种常用的指令编码格式 
  + **可变长度编码格式**、**固定长度编码格式**、**混合型编码格式**
    + **可变长度编码格式**
      + 当指令系统包含多种寻址方式和操作类型时，这种编码方式可以有效减少指令系统的平均指令长度，降低目标代码的大小。
      + 可能会使各条指令的字长和执行时间相差很大。
      + 多数 ==***CISC***== 指令系统均采用了这种编码格式。 
      + <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240117165159423.png" alt="image-20240117165159423" style="zoom:50%;" /> 
    + **固定长度编码格式**
      + 将操作类型和寻址方式一起编码到操作码中。
      + 当寻址方式和操作类型非常少时，这种编码格式非常好。
      + 可以有效地降低译码的复杂度，提高译码的速度。
      + 大部分 ==***RISC***== 的指令系统均采用这种编码格式。
      + <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240117165314980.png" alt="image-20240117165314980" style="zoom:50%;" /> 
    + **混合型编码格式**
      + 提供若干种固定的指令字长。
      + 以期达到既能够减少目标代码长度又能降低译码复杂度的目标。
      + <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240117165459658.png" alt="image-20240117165459658" style="zoom:50%;" /> 



**4. 指令系统实例：MIPS指令系统**

+ **MIPS的寄存器**

  + **32个64位通用寄存器** ***GPRs***
    + R0，R1，…，R31
    + 也称为**整数寄存器**
    + **R0的值永远是0**
  + **32个64位浮点数寄存器** ***FPRs***
    + F0，F1，…，F31
    + 用来存放32个单精度浮点数（32位），也可以用来存放32个双精度浮点数（64位）。
    + 存储单精度浮点数（32位）时，只用到FPR的一半，其另一半没用。
  + 一些特殊寄存器
    + 它们可以与通用寄存器交换数据。
    + 例如浮点状态寄存器：用来保存有关浮点操作结果的信息。

+ **MIPS的数据表示** 

  + **整数**
    + 字节（8位）、 半字（16位）、字（32位）、双字（64位）
  + **浮点数**
    + 单精度浮点数（32位）  双精度浮点数（64位）
  + **字节、半字或者字**在装入**64位**寄存器时，用**零扩展或者用符号位扩展**来填充该寄存器的**剩余部分**。装入以后，对它们将按照**64位整数**的方式进行运算。

+ **MIPS的数据寻址方式** 

  + **立即数寻址**与**偏移量寻址**；
    + 立即数字段和偏移量字段都是**16位**的。
  + **寄存器间接寻址**是通过把 ***0*** 作为**偏移量**来实现的；
  + **16位直接寻址**是通过把**R0（其值永远为0）**作为**基址寄存器**来完成的；
  + MIPS的存储器是按字节寻址的，地址为**64位**；
  + 所有存储器访问都必须是边界对齐的。

+ **MIPS的指令格式** 

  + **寻址方式**编码到操作码中
  + 所有的指令都是**32位**的
  + 操作码占**6位**
  + **3种**指令格式
    + 3种格式中，同名字段的位置固定不变。 
  + 信息宽度不超过主存宽度的信息必须存放在一个存储字内，不能跨边界。
    + 必须做到：**信息在主存中存放的起始地址必须是该信息宽度（字节数）的整数倍**
    + **信息存储的整数边界概念**
      + 满足以下条件
        + 字节信息的起始地址为：×…××××
        + 半字信息的起始地址为：×…×××0
        + 单字信息的起始地址为：×…××00
        + 双字信息的起始地址为：×…×000
      + 存在存储空间的浪费 ，但保证访问速度。
    + <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240117172401179.png" alt="image-20240117172401179" style="zoom:50%;" /> 

+ ==**I类指令**==

  + 包括所有的**load和store指令，立即数指令，分支指令，寄存器跳转指令，寄存器链接跳转指令**。
  + 立即数字段为16位，用于提供立即数或偏移量。

  <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240117172819800.png" alt="image-20240117172819800" style="zoom:50%;" /> 

  + **load指令**
    + 访存有效地址：Regs[rs]＋immediate
    + 从存储器取来的数据放入寄存器rt
  + **store指令**
    + 访存有效地址：Regs[rs]＋immediate
    +  要存入存储器的数据放在寄存器rt中
  + **立即数指令**
    + Regs[rt] ← Regs[rs] op immediate
  + **分支指令**
    + 转移目标地址：Regs[rs]＋immediate，rt无用
  + **寄存器跳转、寄存器跳转并链接**
    + 转移目标地址为Regs[rs]



+ ==**R类指令**==
  + 包括**ALU指令，专用寄存器读/写指令，move指令**等。
  + ALU指令
    + Regs[rd]← Regs[rs] funct Regs[rt]
    + funct为具体的运算操作编码
  + <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240117173525914.png" alt="image-20240117173525914" style="zoom:67%;" /> 



+ ==**J类指令**==
  + 包括**跳转指令，跳转并链接指令，自陷指令，异常返回指令**。
  + 在这类指令中，指令字的**低26位**是**偏移量**，它与PC值相加形成跳转的地址。
  + <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240117173642392.png" alt="image-20240117173642392" style="zoom:67%;" /> 



+ **MIPS的操作**

  + MIPS指令可以分为**四大类**

    + **load和store**
    + **ALU操作**
    + **分支与跳转**
    + **浮点操作**

  + **符号的意义** 

    + x ←n y：从y传送n位到x

    + x，y←z：把z传送到x和y 

    + **下标**：表示字段中具体的位；

      + 对于指令和数据，按从**最高位到最低位（即从左到右）的顺序**依次进行编号，**最高位为第0位**，**次高位为第1位**，依此类推。

      + 下标可以是一个数字，也可以是一个范围。

        > 例如：
        >
        > + Regs[R4]0：寄存器R4的符号位       
        >
        > + Regs[R4]56-63：R4的最低字节

    + Mem：表示**主存**；

      + 按字节寻址，可以传输任意个字节。

    + 上标：用于表示对字段进行复制的次数。

      > 例如：0^32：一个32位长的全0字段

    + 符号##：用于两个字段的拼接，并且可以出现在数据传送的任何一边。

      > 举例：R8、R6：64位的寄存器，则
      >
      > Regs[R8]32-63 ←32 (Mem [Regs[R6]]0)^24 ## Mem [Regs[R6]]
      >
      > 
      >
      > 表示的意义是：
      >
      > 以R6的内容作为地址访问内存，得到的字节按符号位扩展为32位后存入R8的低32位，
      >
      > R8的高32位（即Regs[R8]0-31）不变。  

  + **load和store指令**

    + <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240117174815064.png" alt="image-20240117174815064" style="zoom:67%;" /> 

  + **ALU指令**

    + **寄存器－寄存器型（RR型）指令**或**立即数型**

    + **算术和逻辑操作**：加、减、与、或、异或和移位等

    + <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240117174944535.png" alt="image-20240117174944535" style="zoom:67%;" /> 

    + **R0的值永远是0**，它可以用来合成一些常用的操作。

      > DADDIU R1,R0,#100        给寄存器R1装入常数100
      >
      > DADD R1,R0,R2         把寄存器R2中的数据传送到寄存器R1



+ **MIPS的控制指令**

  + 由一组跳转和一组分支指令来实现控制流的改变

  + 典型的**MIPS控制指令**

    + <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240117175242001.png" alt="image-20240117175242001" style="zoom:67%;" /> 

  + **跳转指令**

    + 根据跳转指令确定目标地址的方式不同以及跳转时是否链接，可以把跳转指令分成4种。
    + 确定目标地址的方式
      + 把指令中的**26位**偏移量**左移2位**（因为指令字长都是4个字节）后，替换程序计数器的**低28位**；
      + 间接跳转：由指令中指定的一个寄存器来给出转移目标地址。
    + 跳转的两种类型
      + **简单跳转：**把目标地址送入程序计数器。
      + **跳转并链接：**把目标地址送入程序计数器，把返回地址（即顺序下一条指令的地址）放入**寄存器R31**。

  + 分支指令（条件转移）

    + 分支条件由指令确定

      > 例如：测试某个寄存器的值是否为零

    + 提供一组比较指令，用于比较两个寄存器的值。

      > 例如：“置小于”指令

    + 有的分支指令可以直接判断寄存器内容是否为负，或者比较两个寄存器是否相等。

    + **分支的目标地址**

      + 由16位带符号偏移量左移两位后和PC相加的结果来决定

    + 一条浮点条件分支指令：通过测试浮点状态寄存器来决定是否进行分支。



+  **MIPS的浮点操作**
  + 由操作码指出操作数是单精度（SP）或双精度（DP）
    + **后缀S：**表示操作数是单精度浮点数
    + **后缀D：**表示是双精度浮点数
  + 浮点操作
    + 包括加、减、乘、除，分别有单精度和双精度指令。
  + 浮点数比较指令
    + 根据比较结果设置浮点状态寄存器中的某一位，以便于后面的分支指令BC1T（若真则分支）或BC1F（若假则分支）测试该位，以决定是否进行分支。



## 中央处理器

### CPU的功能和组成

**1. CPU的功能**

+ CPU具有以下 ***4个*** 方面的基本功能：
  + 指令顺序控制
  + 操作控制 
  + 时间控制
  + 数据加工

**2. CPU的基本组成**

+ 现代CPU一般由**运算器**、**控制器**、**数据通路**和**Cache**组成
+ 数据通路是指**各部件之间通过数据线**的相互连接。
  + 选择什么样的数据通路，对于CPU的性能有很大的影响。
+ CPU执行一条指令，实际上就是由控制器对计算机中的部件发操作控制信号、并对数据通路进行设置来实现的。

**3. 指令执行的基本步骤**

+ 一条指令的执行过程包括3个基本步骤：
  + 取指令：从存储器取出一条指令，该指令的地址由 ***程序计数器PC*** 给出。
  + 译码：对该指令的操作码进行译码分析，确定是哪一种指令，并转到这种指令对应的执行阶段。
  + 执行：按指令操作码的要求执行该指令。
+ <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240117181203107.png" alt="image-20240117181203107" style="zoom:50%;" /> 

**4. 关于模型机**

+ **模型机**：**MIPS结构**的一种简单实现
  + 实现了MIPS指令系统的核心子集。
+ 所包含的指令
  + **算术逻辑运算指令**（**R类型指令**格式）
    + add，sub，and，or，slt （小于比较SLT rd, rs, rt）
    + 操作码字段Op=0
  + **存储器访问指令**（**I类型指令**格式）
    + lw（load word，op=35）
    + sw（store word，Op=43）
  + **等于“0”分支**（**I类型指令**格式）
    + **beqz**，Op=63  
    + 说明：beqz在MIPS中实际上是条伪指令。（假设模型机中有该指令，并假设其操作码为63）
+ 指令的字长：4个字节
+ 指令的格式
  + **R类型**
    + <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240117181721813.png" alt="image-20240117181721813" style="zoom:50%;" /> 
    + **Op——操作码字段**，用IR[Op]或IR[31:26]表示；
    + **rs——第一源操作数字段**，用IR[rs]或IR[25:21]表示；
    + **rt——第二源操作数字段**，用IR[rt]或IR[20:16]表示；
    + **rd——目标操作数字段**（或结果字段），用IR[rd]或IR[15:11]表示；
    + **shamt——无用**；
    + **funct——ALU指令的运算函数码字段**，用IR[funct]或IR[5:0]表示。
  + **I类型**
    + <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240117182411251.png" alt="image-20240117182411251" style="zoom:50%;" /> 
    + **rs——基址寄存器字段**，用IR[rs]或IR[25:21]表示。
      + 对于beqz指令来说，是存放被检测的数据。
    + **adr——偏移量字段**，用IR[adr]或IR[15:0]表示。
      + rs和adr用于计算访存有效地址或分支目标地址。
    + **rt**——对于**load指令**来说，rt所指出的寄存器是**存放所取的数据**；对于**store指令**来说，是**存放要写入存储器的数据**。



###  ==**典型的数据通路组织方式**==

+ **取指令的数据通路**
  + 对于所有指令都是相同的。
  + **主要操作：**把**PC中的地址**送到**指令存储器IM**的IA输入端，读出一条指令。同时用加法器把**PC中的值加4**，使它指向下一条指令。 
  + <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240117183534864.png" alt="image-20240117183534864" style="zoom:50%;" /> 
+ **指令译码**
+ **根据不同的指令操作码进行相应的处理**
  + **R类指令**
    + 用指令中的源寄存器地址字段 ***rs*** 和 ***rt*** 作为地址去访问**通用寄存器组**  ***Reg***，读出两个**源操作数**，送给 ***ALU*** 进行运算。
    + 把运算结果送到寄存器组的 ***WD*** 端，写入由 ***rd*** 字段所指定的目标寄存器。 
    + <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240117184021457.png" alt="image-20240117184021457" style="zoom:50%;" /> 
  + **访存指令（load和store指令）**
    + **load指令**的操作
      + 把指令字中的**16位偏移量**字段进行**符号位扩展**，变成**32位数**，送给ALU；
      + 用**IR[rs]**作为地址去访问寄存器组Reg，读出的操作数送给**ALU**，与上一步扩展了的地址相加，计算出**访存的有效地址**，将之送到**数据存储器DM**的**地址输入端DA**；
      + 从**DM**读出数据（将**DMRead**设置为有效），将该数据送到通用寄存器组的**数据入口端WD**，写入由**IR[rt]**指定的寄存器。
      + <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240117184920314.png" alt="image-20240117184920314" style="zoom:50%;" /> 
    + **store指令**
      + 前两步与load指令的相同。
      + 用IR[rt]作为地址去访问通用寄存器组，读出的数据（在RD2输出端口）送给DM的数据输入端WD，并向DM发写入信号（将DMWrite置为有效），将数据写入DM中相应单元。 
      + <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240117184954748.png" alt="image-20240117184954748" style="zoom:50%;" /> 
    + **beqz指令**
      + Branch信号为有效表示当前指令是一条分支指令。
      + 把指令字中的**16位偏移量字段**（IR[adr]）进行符号位扩展，变成**32位数**，并左移两位送给ALU；
      + 把**PC＋4**送给ALU的另一个输入，与上一步符号位扩展和左移后的地址相加，得到转移目标地址；
      + 用**IR[rs]**作为地址去访问寄存器组Reg，读出操作数并送给**判0**部件。由该部件的输出确定是否分支成功。
      + 如果为真，转移目标地址就成为新的**PC值**，分支成功；否则就用**PC＋4**代替PC中的值，分支失败。
      + <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240117185957217.png" alt="image-20240117185957217" style="zoom:50%;" /> 
+ ==**一种能实现MIPS基本结构的简单数据通路**==
  + <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240117190036185.png" alt="image-20240117190036185" style="zoom:50%;" /> 

### 多周期实现方案

+ 采用更短的时间作为时钟周期，允许指令的执行时间为多个时钟周期。
  + 这个时钟周期往往是一个基本部件的延迟时间。
+ 好处之一：可以共享同一个功能部件（如果是在不同的时钟周期使用该部件的话）。
  + 例如：指令存储器和数据存储器可以合并为一个存储器，做PC+4的加法器可以和ALU合并
+ **指令分步执行过程（按周期分步）**
  + 在一些部件的后面增设临时寄存器，用于存放该部件产生且下一个时钟周期要用的结果。
  + **IR（指令寄存器）**——存放从指令存储器读出的指令；
  + **LMD**——存放从数据存储器读出的数据；
    + 因为访存读取的数据来不及在同一个时钟周期中写入寄存器组。
  + **A和B**——分别存放从寄存器组读出的两个数据；
  + **Imm**—— 存放扩展后的立即值；
  + **ALUo**——存放ALU的运算结果；
  + **cond（1位）**——存放判0部件“=0？”的结果。
+ <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240117192747562.png" alt="image-20240117192747562" style="zoom:67%;" /> 



### 控制器的设计

实现控制器的技术有两种：

+ **硬连逻辑**
+ **微程序设计**

**控制器的组成**

<img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240117193028341.png" alt="image-20240117193028341" style="zoom:50%;" /> 

**1. 指令部件**

+ 主要功能：**取指令和分析指令。**
+ **程序计数器PC**（Program Counter）
  + 程序计数器指出了CPU当前正在执行的指令的地址。
  + CPU每执行完一条指令，就把它**加4**，指向顺序的下一条指令。
+ **指令寄存器IR**（Instruction Register） 
  + 指令寄存器用于存放当前正在执行的指令。 
+ **指令译码器ID**（Instruction Decoder）
  + 对IR中的指令操作码进行译码分析，产生相应操作的控制电平并提供给微操作控制信号形成部件。
  + 有的机器还需对寻址字段进行译码分析，以控制操作数有效地址的形成。
+ **地址形成部件**
  + 根据该指令所指定的寻址方式，形成其操作数有效地址。 

**2. 时序控制部件**

+ **微操作**
  + 一个部件能够完成的不能再细分的基本操作。
  + 计算机中最小的具有独立意义的操作。 
+ **功能：**用来产生一系列时序信号、为各个微操作定时的，以保证各个微操作的顺序执行。 
+ **组成部分**
  + **时钟CP**（Clock Pulses）
    + **CP**：协调计算机各部件操作的同步主时钟。
    + 其工作频率称为计算机的主频。
  + **时序信号发生器TSG**（Timing Signal Generator）
    + 产生机器所需的各种时序信号，以便控制有关部件在不同的时间内完成指定的微操作。

**3. 微操作控制信号形成部件**

+ 根据指令部件提供的操作控制电位、时序控制部件所提供的各种时序信号，以及有关的状态条件，产生计算机所需要的各种微操作的控制信号。

**4. 中断控制逻辑**

+ 称为中断机构。
+ 用于异常或突发情况的处理。

**5. 程序状态寄存器PSR**

+ 存放程序状态字PSW。
  + PSW反映了计算机系统目前的基本状态，包括目态/管态、指令执行的结果特征以及与中断有关的信息等。
  + 指令执行的结果特征包括运算结果为0、结果为负、结果溢出等。



### 控制方式与时序系统

==**1. 控制方式**==

+ 同步控制方式 
  + 机器有统一的时钟信号（称为**系统时钟**），所有的微操作控制信号**都与时钟信号同步**。
  + 把一条指令的执行过程划分为若干个长度相等的时间区间，然后把该指令的微操作按顺序安排到每一个时间区间中。这个时间区间称为**节拍**。
    + 其**宽度（时间）与一个时钟周期的时间相同**。
    + 节拍宽度的确定取决于所有微操作中时间最长的微操作所需的时间。 
  + **优点：**时序关系简单，控制方便，而且便于调试，系统较为可靠。 
  + **缺点：**有时间浪费 。
+ **异步控制方式** 
  + 各部件之间没有统一的时钟和节拍，而是各部件有自己的时钟。
  + 微操作控制信号采用应答方式衔接。前一个操作完成后给出回答信号，启动下一个操作。 
  + **优点：**没有时间上的浪费，效率高。 
  + **缺点 ：**设计比较复杂，所需的器材较多，系统调试难度较大，且工作过程中的可靠性不易保证。 

**2. 时序系统**

+ 时钟、节拍和节拍电位构成了计算机的时序系统。 
  + **指令周期：**从取指令、分析指令到执行完该指令所需的全部时间。
    + 指令周期一般由**若干个时钟周期**组成 。
  + **节拍** 
    + 节拍一般用具有一定宽度的电位信号表示，称为**节拍电位**。
  + **脉冲：** 用于寄存器的复位或打入脉冲等。 
+ 指令周期、节拍、脉冲 之间的关系：
  + 其中：每个指令周期包含**5个节拍T0～T4**、每个节拍有一个脉冲 
+ <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240117193654005.png" alt="image-20240117193654005" style="zoom:50%;" /> 

**3. 模型机控制器的设计**

<img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240117193835745.png" alt="image-20240117193835745" style="zoom:50%;" /> 

+ **使用指令译码器和一个计数器及其译码器来形成各状态的时序。**
  + **R-TYPE**表示是R类指令
  + **LD、ST、BEQZ**表示分别是lw、sw、beqz指令 
  + <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240117193923979.png" alt="image-20240117193923979" style="zoom:50%;" /> 
+ **进入各状态的条件**
  + <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240117194001825.png" alt="image-20240117194001825" style="zoom:50%;" /> 
+ **得到各控制信号的逻辑表达式**
  + <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240117194022843.png" alt="image-20240117194022843" style="zoom:50%;" /> 



### 流水线技术

+ **流水线技术**

  + 把一个重复的过程分解为若干个子过程，每个子过程由专门的功能部件来实现。
  + 把多个处理过程在时间上错开，依次通过各功能段，这样，每个子过程就可以与其它的子过程并行进行。

+ 流水线中的每个子过程及其功能部件称为**流水线的级或段**，段与段相互连接形成流水线。**流水线的段数**称为**流水线的深度**。

+ 流水线中各段的时间应尽可能相等，否则将引起流水线堵塞、断流。

  + 时间最长的段将成为**流水线的瓶颈**。

+ 流水线每一个段的后面都要有一个缓冲寄存器（锁存器），称为**流水寄存器**。

  + 作用：在相邻的两段之间传送数据，以保证提供后面要用到的信息，并把各段的处理工作相互隔离。

+ 流水线需要有**通过时间**和**排空时间**。

  + **通过时间：**第一个任务从进入流水线到流出结果所需的时间。
  + **排空时间：**最后一个任务从进入流水线到流出结果所需的时间。

+ **流水线的性能指标**

  + **吞吐率：**在单位时间内流水线所完成的任务数量或输出结果的数量。

    + <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240117194349477.png" alt="image-20240117194349477" style="zoom:50%;" /> 
    + n：任务数
    + Tk：处理完成n个任务所用的时间

  + **加速比：**完成同样一批任务，不使用流水线所用的时间与使用流水线所用的时间之比。

    + 假设：不使用流水线（即顺序执行）所用的时间为**Ts**，使用流水线后所用的时间为**Tk**，则该流水线的加速比为：
    + <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240117194424061.png" alt="image-20240117194424061" style="zoom:50%;" /> 

  + **流水线的效率**

    + 流水线中的设备实际使用时间与整个运行时间的比值，即流水线设备的利用率。

    

## 微程序控制器

**1. 微操作和微操作控制信号**

+ **微操作控制信号（微命令）：**控制部件向执行部件发出的各种控制命令。
  + 例如：打开或关闭某个控制门，多路器选择哪个输入等。
+ **微操作：**指执行部件接受控制信号后所进行的最基本的、不可再细分的操作。
  + 分为两种：
    + **相容的**微操作：**可以同时进行**的微操作。
    + **互斥的**微操作：**不能同时进行**的微操作 。

**2. 微指令和微程序**

+ **微指令：**用来产生微控制信号的二进制编码字。用于控制**完成一组微操作**。 
+ **微程序：** **一序列微指令**构成的有序集合。
+ **每一条机器指令都对应于一段微程序**，通过解释执行这段微程序，完成指令所规定的操作。

**3. 微指令周期**

+ **微指令周期：**微程序控制器的工作周期。 
+ 从控制存储器读取一条微指令到执行完相应的微操作所需时间的最大值。 



### 微指令的编码方法

+ 一条微指令由**两部分**构成
  + **微操作控制字段**
  + **地址控制字段** 
+ 对微操作控制字段进行编码的方法有**4种**
  + **直接控制编码、最短字长编码、分段直接编码、分段间接编码**



**1. 直接控制编码法（不译码法）**

+ **微操作控制字段的每一位直接对应一个微操作。**
  + 当某位为1时，就表示执行相应的微操作；
  + 为0时就不执行该微操作。
+ **优点：**结构简单，并行性最好，操作速度快。
+ **缺点：**微指令字太长。 
+ <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240117200938510.png" alt="image-20240117200938510" style="zoom:50%;" /> 

**2. 最短字长编码法**

+ 将所有的**微命令进行统一的二进制编码**，**每条指令只定义一个微操作**。
+ **微操作控制字段的长度L与微命令的总数N**的关系
  + **L ≥ log2N**
+ **优缺点**
  + 微指令的字长**最短**，但要经过**译码后**才能得到所需要的微命令，执行速度会受到影响。
  + 在**一条微指令**中只能**产生一个微命令**，无法利用硬件所具有的并行性。 
+ <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240117201223503.png" alt="image-20240117201223503" style="zoom:67%;" /> 



**3. 字段直接编码法**

+ 把**微操作控制字段**进一步**划分为若干个字段**，每个字段**单独编码**，**每个码点表示一个微命令**。 
  + 上面两种方法的**折中方案**：
  + **字段之间采用直接控制，字段内部采用最短字长编码。** 
+ 进行字段划分时，需要注意以下原则：
  + 可以按功能和部件划分，对于机器中的每一种功能类型或每一个部件，分配一个字段；
  + 把互斥的微操作分在同一字段，把相容的微操作分到不同的字段 ；
  + 字段的划分应与数据通路相适应；
  + 一般每个字段应留出一个码点，用于表示不发任何微命令。
+ <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240117201624614.png" alt="image-20240117201624614" style="zoom:50%;" /> 



**4. 字段间接编码**

+ 字段的编码的含义（即表示什么微命令）要由另外一个字段的编码来解释确定。 
+ 一个解释字段要同时对多个字段进行控制（解释），才能有效地缩短字长。
+ 解释字段应有某些分类的特征
+ 

<img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240117202026977.png" alt="image-20240117202026977" style="zoom:50%;" /> 



### 微指令格式

**1. 水平型微指令**

+ 一次能**定义并执行多个微操作**的微指令。 

+ 具有以下**特点**： 

  + **微指令字较长**，一般为几十位到上百位。

    > 例如：VAX-11/780机的微指令字长为96位。 

  + 微指令中描述并行微操作的能力强，在一个**微周期**中，能**并行执行多个微操作**。 

  + 微指令**译码简单**，一般采用**直接控制编码法**和分段直接编码法。 

+ **优缺点**

  + **并行操作能力强**、**执行速度快**、**代码长度短**。
  + 微指令字比较长，明显**增加了控存的宽度**。 
  + 编制微程序**比较复杂**，难度较大，也不易实现设计的自动化。 



**2. 垂直型微指令**

+ 一次只能定义**一两个微操作**（一般是**数据传送**），而且微指令**字长比较短**。
+ <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240117202706886.png" alt="image-20240117202706886" style="zoom:50%;" /> 
+ ***μOP***：微操作码
+ 把两个源寄存器中的内容进行 ***μOP*** 所规定的操作，结果存入目的寄存器字段所指定的寄存器中。
+ **特点**
  + **微指令字短**，一般为一、二十来位；
  + 微指令的**并行微操作能力差**，一条微指令只能控制数据通路的一两种信息传送；
  + 垂直型微指令是通过一个称为**微操作码的字段**来**定义微指令的基本功能和信息传送路径**。执行时，需进行完全译码，**译码比较复杂**。
  + 微指令的各二进制位与数据通路的各个控制点之间完全不存在直接对应关系。
+ **优点**
  + **直观**、**规整**，易于编制微程序和实现设计自动化。
  + 微指令**字比较短**，控存的横向比较窄。
  + 可以直接应用现有程序设计语言的结果。
+ **缺点**
  + **微程序比较长**，而且垂直型微指令产生微命令要经过译码，**程序执行速度慢**。
  + 描述**并行微操作的能力很差**，不适合用于数据通路有较多并行性的机器。 



### 微程序的顺序控制

+ 微程序的顺序控制问题（微程序地址控制问题）
  + **初始微地址 ：机器指令所对应的微程序的入口地址** 
  + **后继微地址：形成下一条微指令的地址**

**1. 微程序入口地址的形成**

+ **公用的“取指令”微程序**一般存放在控存中第0号单元或其它指定的控存单元开始的一片控存区域中。

  + （**这个地址是固定不变的**） 

+ 根据IR中的操作码，找到该指令所对用的微程序的入口地址。

+ 两种实现方法：

  + **直接对应法** 

    + **所有指令的操作码的位数和位置都相同时**

      + 直接把操作码与微地址码的部分位对应。 

        > 例如，可指定微地址：Const｜Op
        >
        > （Op：操作码，Const：常数） 

    + **操作码一般是连续编码的**，所以直接对应过去的地址是连续的。 

    + 改进：

      +  在上述拼接的微地址后面再拼接若干位0（设为n位），使得每个操作码在所对用的区域中有一片单元（2^n个）可用。 

    + 如果操作码的位数和位置不固定，但在每一类指令中，操作码的位数和位置都是相同的，则可以采用两级分转。

  + **查表法**

    + 在操作码的位数或位置不固定的情况下，需要用专门的硬件实现操作码到入口地址的映象。
    + 用**PLA或ROM**实现一个表格，该表格给出了各操作码所对应的微程序的入口地址。
    + 使用该表时，只要用操作码作为输入，就能在其输出端得到该指令的微程序入口地址。



==**2. 后继微地址的形成**==

两种方式：**增量方式，断定方式**。

+ ==**增量方式**==
  + 设置一个微程序计数器 ***μPC*** 。
  + 顺序执行时，给 ***μPC*** 增加一个**增量（通常为1）**给出下一条微指令的地址。
  + 遇到转移时，由**微指令给出转移目标的微地址**。 
  + 采用这种方式的微指令格式： 
  + <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240117204530796.png" alt="image-20240117204530796" style="zoom:50%;" /> 
  + 微地址字段 ***SCF*** 分成两个字段
    + 转移控制字段 ***BCF***
      +  用于规定是顺序执行还是转移。如果是转移，就由BCF指出转移地址的来源。
    + 转移地址字段 ***BAF***
  + 转移地址的来源有**3种** 
    + 由 ***BAF*** 给出的地址；
    + 机器指令所对应的微程序的入口地址；
    + 微子程序入口地址和返回地址（存放在返回地址寄存器中）。 
  + **优点： ** **SCF字段比较短**，后继微地址生成逻辑比较简单，编制微程序也比较容易。
  + **缺点：**不能**直接实现多路转移**。 
  + <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240117205351364.png" alt="image-20240117205351364" style="zoom:50%;" /> 
+ ==**断定方式**==
  + 按以下方式**确定后继微地址**
    + 由微程序设计者直接指定；
    + 由微程序设计者指定的**测试判别逻辑字段控制产生**。
  + **后继微地址**由两部分组成
    + **非测试地址**
      + 微程序设计者直接指定的，是不变的，构成微地址的**高位部分**。
    + **测试地址**
      + 在微程序的执行过程中，通过测试一些状态位而动态决定的，它构成微地址的**低位部分**。
  + 微地址格式
    + <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240117205744848.png" alt="image-20240117205744848" style="zoom:50%;" /> 
  + 微指令格式 
    + <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240117205804404.png" alt="image-20240117205804404" style="zoom:50%;" /> 
    + 测试地址的位数决定了并行分支的路数，而且也决定了测试控制字段的个数。 
    + 当测试地址位数为m时，分支的路数为2^m，而测试字段的个数为m。至于测试字段的位数n，则是取决于测试条件的个数N，一般地，有n= [log2N]+1。 
  + **优点**
    + 能够实现**快速多路转移**，提高微程序的**执行速度**。而且微程序在控存中的存放位置也很灵活、方便。
  + **缺点**
    + 后继微地址的生成方法**比较复杂**，微程序的**执行顺序不直观**。 



## 运算方法与运算器



### 移位运算

**移位操作时，要指明：**

+ 移位的方向：左移或右移
+ 一次移位的位数
+ 移位的性质
  + 根据移位性质划分的3种移位运算 ：
    + 逻辑移位
    + 算术移位
    + 循环移位

**1. 逻辑移位**

被移位的数据是逻辑数，既无符号，也没有数值的大小。

+ **逻辑左移shl**：将数据的各位依次向左移一位，最高位移出丢弃，**最低位移入“0”**。
+ **逻辑右移shr**：将数据的各位依次向右移一位，最低位移出丢弃，**最高位移入“0”**。
+ <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240118202714526.png" alt="image-20240118202714526" style="zoom:67%;" /> 



**2. 循环移位**

+ 循环移位中将被移位数据的左右两端连接起来，形成**闭合的移位环路**。
+ <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240118202750885.png" alt="image-20240118202750885" style="zoom:67%;" /> 



**3. 算术移位**

对带符号的数进行移位，移位会引起数值的变化。

+ 算术右移一位相当于将该数除以2（乘以1/2）
+ 算术左移一位相当于将该数乘以2
+ **原码算术移位**
  + 符号位不参加移位，只是将相应的数值位依次左移（或右移），移出去的最高位（或最低位）自动丢弃，最低位（或最高位）移入“0”。
  + <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240118202913353.png" alt="image-20240118202913353" style="zoom:67%;" /> 
+ **补码算术移位**
  + 对补码表示的数进行算术移位时，符号位一起参加移位，其移位规则为：
  + 算术左移：连同符号位一起各位依次向左移一位，**最高位（符号位）移出丢弃**，最低位移入“0”。
  + 算术右移：连同符号位一起各位依次向右移一位，**符号位保持不变**，最低位移出丢弃。
  + <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240118202952630.png" alt="image-20240118202952630" style="zoom:67%;" /> 





### 定点数的加减法运算

**只讨论补码的加减法运算。**



**1. 补码加减法运算规则**

+ <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240118203219642.png" alt="image-20240118203219642" style="zoom:67%;" /> 
+ 补码加减运算的基本规则：
  + 参加运算的两个操作数和运算结果均用**补码**表示；
  + **符号位与数值位一起参加运算**；
  + 补码加法时，将两个补码数直接相加，即得两数之和的补码；
  + 补码减法运算转化为加法运算进行，将[X]补与[－Y]补相加，即得两数之差的补码；
  + 如果**运算结果超过了模**（即**符号位运算产生了进位**），则将该进位**自动丢弃**。 



**2. 溢出的判断**

<img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240118203411245.png" alt="image-20240118203411245" style="zoom:50%;" /> 

+ **溢出：**运算结果超过了定点数的表示范围。
  + 如果两个**正数相加**的结果**大于**机器所能表示的**最大正数**，则称为**正溢出**。
  + 如果两个**负数相加**的结果**小于**机器所能表示的**最小负数**，则称为**负溢出**。 
+ **3种常用的溢出判断方法**
  + **采用两个操作数和结果的符号来判断**
    + 当两个同号数的补码相加，若得到的结果的符号与两个操作数的符号不同，则发生了溢出。 
    + 溢出的判断条件 
    + <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240118203513765.png" alt="image-20240118203513765" style="zoom:50%;" /> 
    + 当**overflow=1**时，则发生了溢出。
    + 其中：Xf、Yf：两个操作数的符号位，Ff：运算结果的符号位。
  + 采用**最高数值位产生的进位与符号位产生的进位**是否相同来判断。当不相同时，则发生了溢出。
    + 溢出的判断条件
    + <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240118203635819.png" alt="image-20240118203635819" style="zoom:67%;" /> 
    + 其中：Cf、Cn-1分别是最高数值位的进位和符号位产生的进位。
    + <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240118203654421.png" alt="image-20240118203654421" style="zoom:50%;" /> 
  + **采用变形补码来判断**
    + 采用**两位符号位**表示的补码叫**变形补码** 。
      + <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240118203828358.png" alt="image-20240118203828358" style="zoom:50%;" /> 
    + 采用变形补码运算时，**两个符号位与数值部分一起参加运算**。如果运算结果的两个符号位**相异**（为10或01），则产生了溢出。
      + 若结果符号位为**01**，则表示结果为**正溢出**；
      + 若结果符号位为**10**，则表示结果为**负溢出**。
    + 溢出的判断条件 
    + <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240118203807224.png" alt="image-20240118203807224" style="zoom:67%;" /> 
    + 其中：Ff1、Ff2为运算结果的两个符号位。



### 定点数的乘除法运算

**1. 原码乘法运算**

<img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240118204105280.png" alt="image-20240118204105280" style="zoom:50%;" /> 

+ 乘法运算规则：
  + 符号位单独处理：同号相乘，乘积为正；异号相乘，乘积为负。
  + <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240118204127465.png" alt="image-20240118204127465" style="zoom:67%;" /> 
  + 结果的数值部分是两个数的绝对值相乘，即两个正数相乘。
+ ==**原码一位乘法的运算规则**==
  + （1）符号位**单独处理**。用被乘数和乘数的数值位部分进行运算。设部分积的初值为0。
  + （2）若**乘数Y的最低位Y0＝0**，则将**上一次的部分积右移一位**，得新的部分积；
              若**乘数Y的最低位Y0＝1**，则将**上一次的部分积与被乘数X相加**，然后**右移一位**，得新的部分积。 乘数Y循环右移一位。 
  + （3）将上述过程（2）重复n遍，n为被乘数和乘数数值位的位数。最后得到的部分积就是乘积的数值部分。
  + <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240118205401566.png" alt="image-20240118205401566" style="zoom:50%;" /> 
  + <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240118205409374.png" alt="image-20240118205409374" style="zoom:50%;" /> 
+ **实现原码一位乘法的逻辑电路** 
  + <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240118205437394.png" alt="image-20240118205437394" style="zoom:67%;" /> 
  + **被乘数X**保存在n位寄存器中；
  + **乘数Y、部分积高位部分U、部分积低位部分V**保存在**n位移位寄存器**中，
  + 运算结束后，**UV**中分别存放**乘积的高n位和低n位**。
  + 计数器为**减1计数器**，初始值为n。
    + 用来控制乘法运算的步数。
  + 控制电路用来产生运算过程中所需的控制信号。
    + 它根据计数器的值、Y0的值以及CP脉冲，产生寄存器C、U的“载入”信号，U、V、Y的“右移”一位信号，计数器的“减1”信号。 
+ ==**补码一位乘法**==
  + <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240118205622580.png" alt="image-20240118205622580" style="zoom:50%;" /> 
  + Booth乘法的运算规则
    + （1）参加运算的数都是补码表示的，符号位一同参加运算，得到的结果也是补码数。
    + （2）乘数Y的末尾增设一位附加位**Y-1**，初始值为**0**。部分积的初值为**0**。
    + （3）根据乘数Y的最低两位**Y0Y-1**的值，进行相应的操作。具体操作如表所示。
      + 其中“－X”是通过“＋[－X]补”来实现。
    + （4）将上述过程（3）重复n遍，最后得到的部分积就是运算结果。
  + <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240118205729049.png" alt="image-20240118205729049" style="zoom:50%;" /> 
  + <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240118205826165.png" alt="image-20240118205826165" style="zoom:50%;" /> 
  + <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240118205835730.png" alt="image-20240118205835730" style="zoom:50%;" /> 
  + <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240118210216534.png" alt="image-20240118210216534" style="zoom:50%;" /> 



### 定点运算器的构成



**1. 算术逻辑运算单元ALU**

由**逻辑运算部件**、**算术运算部件**以及**多路选择器**3部分组成。

+ **逻辑运算部件** 
  + 直接用相应的逻辑门就能实现基本的**逻辑运算**。
  + 能完成两个**n位数A和B**的与运算、或运算、异或运算的逻辑运算单元。
  + <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240118210939566.png" alt="image-20240118210939566" style="zoom:50%;" />  
+ **算术运算部件** 
  + 主要完成**加法和减法**运算
  + **核心**：一个二进制并行加法器 
  + <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240118211102861.png" alt="image-20240118211102861" style="zoom:50%;" /> 
+ **n位的ALU**
  + <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240118211129372.png" alt="image-20240118211129372" style="zoom:50%;" /> 



### ==浮点运算==



**1. 浮点加减运算**

<img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240118211654873.png" alt="image-20240118211654873" style="zoom:50%;" /> 

+ 浮点加减法运算的步骤:
+ **判0操作、对阶、尾数加/减、规格化与舍入**
+ （在规格化的过程中还要判断运算结果是否溢出）
+ **1. 判0操作**
  + 两个操作数X和Y中有为“0”的，则不需要进行运算，直接就能设置运算结果（为0），运算结束。
  + 否则进入下一步。
+ **2. 对阶** 
  + 使小数点对齐 
  + 需要对其中的一个操作数进行变换，使两个操作数的阶码相等。
  + 分两步实现 
    + 求**阶差△E＝XE－YE。**
    + 若**△E＞0**，则表示**X的阶码大于Y的阶码**，需调整操作数Y。
      + 将**Y的尾数YM右移**；
      + 每**右移**一位，其**阶码YE加1**，直到两数的**阶码相等**为止。
    + 若△E＜0，则表示X的阶码小于Y的阶码，需调整操作数X。调整的方法与上面的一样。
+ **3. 尾数加/减**
  + 将两数的尾数XM和YM，按照相应的定点加减运算规则进行加减法运算，得到运算结果的尾数。
+ **4. 结果规格化并判溢出**
  + 若得到的运算结果的**绝对值大于1**，则需要**右规**。
    + 将该结果**右移一位**，相应的**阶码加1**。
    + **右规最多只有一位**。
  + 若得到的运算结果的**绝对值小于1**，则需要**左规**。
    + 将该结果左移，每**左移一位**，相应的**阶码减1**；
    + 直到运算结果的**绝对值大于等于1/2**为止。 
  + 在规格化时，阶码每次加1或减1以后，都要判断阶码是否超出所能表示的范围。
    + 若**阶码上溢**，即阶码大于可能表示的最大正数，则**置溢出标志**，或者将结果当作**＋∞或－∞**处理。
    + 若**阶码下溢**，即阶码小于可能表示的最小负数，这时，可以**置溢出标志**，也可以将结果当作**0**处理。
+ **5. 舍入处理**
+ 常用的舍入方法有以下几种：
  + 0舍1入法
  + 截断法
  + 朝＋∞舍入法
  + 朝－∞舍入法 
+ 几个数值在不同舍入方法下的舍入结果 
  + <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240118212423495.png" alt="image-20240118212423495" style="zoom:50%;" /> 

**==2. 浮点加法运算例子==**

<img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240118212838473.png" alt="image-20240118212838473" style="zoom:50%;" /> 

<img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240118212851928.png" alt="image-20240118212851928" style="zoom:50%;" /> 

<img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240118212904160.png" alt="image-20240118212904160" style="zoom:50%;" /> 





## 存储器



#### 存储子系统概述

+ **三级存储系统**
  + **Cache（高速缓冲存储器）**
  + **主存储器**
  + **磁盘存储器（辅存）**
+ 最靠近CPU的Cache速度最快，容量最小；离CPU最远的硬盘速度最慢，但容量最大。
+ 必须保证：CPU所访问的指令和数据的绝大部分都能在Cache中找到。
+ <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240118213630485.png" alt="image-20240118213630485" style="zoom:50%;" /> 



+ **存储器的分类**
  + 按在**计算机系统中的作用**分类
    + **主存储器**
      + 又称为内存储器，简称为**主存或内存**。
      + 它是整个存储系统的核心，用来存放计算机当前运行的程序以及所需的数据，CPU可直接随机地对它进行访问。
    + **辅助存储器**
      + 又称为外存储器，简称为辅存或外存。
      + 为了弥补主存的容量不足。
      + 用来存放暂时不用的程序和数据。
      + CPU不能直接访问它，当需要运行辅助存储器中的程序时，需将它们调入主存后供CPU使用。
    + **高速缓冲存储器Cache**
      + 为了弥补主存的速度不足
      + 位于CPU和主存储器之间
  + 按**存取方式**分类
    + **随机存储器** ***RAM***
      + 可**随机地读取**或**写入存储器**的任何一个单元，访问时间是固定的，与存储单元的物理位置无关。
      + 在**系统断电后大多数随机存储器RAM所保存的信息将丢失**。
    + **只读存储器** ***ROM***
      + 只能**随机读取存储器**的任何一个单元，不能随机地写入信息。
      + **一个特点：系统断电后，所保存的信息不会丢失。**
    + **顺序存取存储器** ***SAM***
      + 只能按**顺序访问存储器中的信息**，访问时间与信息在存储器中所处的物理位置有关。
      + 信息通常以文件或数据块的形式存放。



#### 主存储器的组成

<img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240118214408738.png" alt="image-20240118214408738" style="zoom:50%;" /> 

#### 主存的主要技术指标

+ **存储容量**
  + 一个存储器中所能存储的二进制信息的总量。
  + 常用**位（b）和字节（B）**来表示。
    + 如64Kb、512KB、4MB。
+ **存取速度**
  + 指访问存储器的速度。
  + **存取时间T~A~**：
    + 又称为**访问时间或读写时间**，它是指从启动一次存储器访存操作到完成该操作所需要的时间。 
  + **存储周期T~M~：**
    + 指连续两次启动存储器访问所需的最小时间间隔。
    + 包括存储器的**存取时间和自身恢复时间**
    + 存储周期通常大于或等于存取时间
  + **主存带宽B~M~：**
    + 存储器单位时间内所能存取的信息量。
    + 也称为数据传输率或主存的数据传频率
    + 单位为位/秒或字节/秒 
    + **B~M~  ＝ 每个存储单元的位数/TM（位/秒）＝ 每个存储单元的位数/（TM×8）（字节/秒）**
    + 提高BM的方法有三种
      + 增加存储单元的位数，减少T~M~，采用多个存储体
  + 可靠性
    + 在规定的时间内，存储器无故障读写的概率。
    + 通常，用**平均无故障间隔时间（Mean Time Between Failures，MTBF）**来衡量可靠性。
    + MTBF越长，说明存储器的可靠性越高。
  + 价格
    + 常用每位价格来衡量存储器的价格，它等于存储器的总价格与存储器总容量之比。



#### 随机存储器

**1. 静态随机存储器SRAM**

+ **存储位元电路：**存储一位二进制信息的电路 
+ 一个六管SRAM存储位元电路 
  + <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240118221038997.png" alt="image-20240118221038997" style="zoom:50%;" /> 
+ **T1导通、T2截止为“1”状态**，这时位线D为高电位，**保存信息“1”**；
+ **T2导通，T1截止为“0”状态**，这时位线D为低电位，**保存信息“0”**。
+ **保持** 
  + 当字驱动线W处于低电位时，门控管T5、T6都处于截止状态，使得触发器保持原来状态不会改变。
  + 当要写入或读出信息时，要使字驱动线处于高电位，将T5、T6管打开处于导通状态，两根位线分别连接到A、B两点。
+ **写入操作** 
  + 写入“1”
    + 在位线$\overline{D}$ 上加低电位，位线D上加高电位。
    + T1导通，T2截止，保存了信息“1”。
  + 写入“0” 
    + 在位线$\overline{D}$ 上加高电位，位线D上加低电位。
    + T1截止，T2导通，保存了信息“0”。
+ **读操作** 
  + 若原存信息为“1”，即T1导通，T2截止。
    + 位线$\overline{D}$ 为低电位，位线D为高电位，表示读出的信息为“1”。
  + 若原存信息为“0”，即T2导通，T1截止。
    + 位线$\overline{D}$ 为高电位，位线D为低电位，表示读出的信息为“0”。
+ **非破坏性读出 ：**读出后原存信息保持没变。  
+ **SRAM的基本存储位元电路的特点：**
  + 所含晶体管较多，故**集成度较低，功耗较大**。
  + 但SRAM**工作速度快，稳定可靠，不需要外加刷新电路**，从而简化了外电路设计。 



**2. 动态随机存储器DRAM**

+ 利用MOS晶体管的管极电容来存储二进制信息。
  + **电容上有电荷：二进制信息“1”**
  + **电容上无电荷：二进制信息 “0”** 
+ 一个单管DRAM存储位元电路
  + 由**一个晶体管T和一个电容C**构成
  + C上有电荷表示所存信息为“1”，无电荷表示所存信息为“0”。 
+ <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240118221553281.png" alt="image-20240118221553281" style="zoom:50%;" /> 
+ **保持** 
  + 当字驱动线W处于低电位时，T截止，切断了电容C的通路，使得C保持其电荷不变。
  + 当要写入或读出信息时，首先要使字驱动线处于高电位，将T管打开处于导通状态，电容C与位线相连。
+ **写入操作** 
  + 写入“1” ：在位线D上加高电位，通过T对电容C充电，使C充满正电荷，写入的信息“1”以电荷的形式保存在电容上。 
  + 写入“0”：在位线D上加低电位，电容C通过T放电，使C上原有电荷几乎放光，存储了信息“0”。 
+ **读操作**
  + 当T导通以后，若原存信息为“1”，电容C上的电荷通过T输出到位线上，在位线上检测到电流，表示所存信息为“1”。
  + 若原存信息为“0”，电容C上几乎无电荷，在位线上检测不到电流，表示所存信息为“0”。
  + **破坏性读出**
    + 读操作后需要进行**恢复工作**。 
    + 恢复：**再给电容C充电，相当于进行一次写“1”的操作** 
+ **DRAM的特点**
  + 基本存储位元电路中所含**晶体管数目少、集成度高、成本低、功耗小**。
  + 它需**外加刷新电路**。
  + 工作速度**比SRAM慢得多**。
    + 破坏性读出且需要刷新



**3. 存储芯片的内部组成**

+ **线性组成** 
  + 所有存储单元线性排成一列，每一个存储单元中的多个存储位元的字驱动线连在一起，构成字线；位线分别连接到相应的数据线。 
  + <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240118221938546.png" alt="image-20240118221938546" style="zoom:67%;" /> 
  + 当地址位数n较大时，译码器的规模随之增大很多，导致电路复杂，译码时间很长，存储芯片的速度太慢。
+ **二维组成** 
  + 所有存储单元排列成矩阵形式，将地址分成两组，分别送给X方向和Y方向的两个译码器，在行和列的交叉共同选择一个存储单元，对其进行读写操作。
  + 适合于构造大容量的存储芯片 。
  + **一个采用二维组成的16字×1位的存储芯片** 
  + <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240118222020393.png" alt="image-20240118222020393" style="zoom:50%;" /> 



**==4. 动态RAM的刷新==**

+ **刷新**
  + DRAM是利用电容上保存的电荷来存储信息的，由于存在漏电阻，即使电源不掉电，时间长了，电容上的电荷也会慢慢泄漏掉，DRAM内存储的信息会自动消失。
  + 为维持DRAM所存信息不变，需要定时地对DRAM中的电容充电，以补充泄漏掉的电荷。
    这个过程叫刷新。 
+ **采用读出方式进行刷新** 
+ **刷新周期**
  + 从上一次对整个存储器刷新结束到下一次对整个存储器刷新结束所需的时间。
  + 大小主要取决于电容电荷的泄漏速度，一般为2ms、4ms、8ms或更长。
+ **3种不同的刷新方式** 
+ 例如：某存储器芯片容量为**16K×1**位，存储矩阵为**128×128**，
            在**2ms（刷新周期）内要对128行**全部刷新一遍。
            假设存储器的存取周期为**0.5$\mu s$** 。 
+ **==1. 集中式刷新==**
  + 在一个刷新周期内，集中一段时间连续地对全部存储单元逐行刷新一遍。
  + 在刷新操作期间，**不允许CPU对存储器进行正常的访问**。
  + <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240118222356876.png" alt="image-20240118222356876" style="zoom:67%;" /> 
  + **优点：读写操作时不受刷新工作的影响，系统的存取速度比较高。**
  + **主要缺点：**在集中刷新期间必须**停止读写**，这一段时间称为“死区”， 而且**存储容量越大，死区就越长。**
+ **==2.分散式刷新==**
  + 把对每行存储单元的刷新分散到每个系统存取周期内完成。
  + 此时系统存取周期被分为两部分，周期前半段时间进行正常的存储器访问，后半段时间进行刷新操作。
  + 在一个系统存取周期内刷新存储矩阵中的一行。 
  + 增加了系统的存取周期。
  + 如存储芯片的存取周期为**0.5$\mu s$**，则系统存取周期应为**1$\mu s$**。
  + <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240118222732224.png" alt="image-20240118222732224" style="zoom:67%;" /> 
  + **优点：没有死区。**
  + **缺点：刷新过于频繁。**系统存取周期是存储芯片存取周期的两倍，降低了访问存储器的速度。
+ ==**3. 异步式刷新 **==
  + **把刷新操作平均分配到整个最大刷新间隔内进行。**
  + **相邻两行的刷新间隔为：**
    + **==最大刷新间隔时间÷行数==**
  + <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240118222926328.png" alt="image-20240118222926328" style="zoom:67%;" /> 

### ==主存的设计==

**1K = 2^8^，故 *N* K大小的RAM芯片需要（$8+\lceil \log_{2}(N) \rceil$）根地址线**

**==1. 位扩展法==**

+ 在**位数方向扩展（增加存储字长）**，而芯片的字数和存储器的字数是一致的。

+ 位扩展的连接方式

  + 将各存储芯片的**地址线、片选线和读写线相应地并联**起来，

  + 各芯片的**数据线单独引出**。 

+ <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240118223116295.png" alt="image-20240118223116295" style="zoom:50%;" /> 

+    

**==2. 字扩展法==**

+ 在**字数方向扩展，而位数不变**。
+ 字扩展的连接方式
  + 将各存储芯片的地址线、数据线、读写线并联，由片选线来区分各个芯片。
+ 例如：用**2K×8**位的RAM存储芯片构成**8K×8位的存储器**。需要**4片**RAM存储芯片。
  + **8K×8位的存储器：13位地址**
  + **2K×8位的RAM存储芯片：11位地址**
+ **13位地址：11位作为存储芯片的片内地址，2位地址用于形成4片芯片的片选信号。**
+ 可有两种不同的选择方法：
+ <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240118224043945.png" alt="image-20240118224043945" style="zoom:50%;" /> 
+ <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240118224055421.png" alt="image-20240118224055421" style="zoom:50%;" /> 

**==3.字和位同时扩展法==**

+ 例如：使用**2K×4位**的存储芯片构成4K×8位存储器，则需要在位和字两个方向同时扩展。
+ 需要**4片**RAM存储芯片，分为**2组**，**组内进行位扩展，组与组之间进行字扩展**。 
+ <img src="C:\Users\IamNotLCB\AppData\Roaming\Typora\typora-user-images\image-20240118224141251.png" alt="image-20240118224141251" style="zoom:50%;" /> 





